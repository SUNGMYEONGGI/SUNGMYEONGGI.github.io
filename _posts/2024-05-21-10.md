---
title: AI ê°œë°œì ì·¨ì—…ì„ ìœ„í•œ ì½”ë”©í…ŒìŠ¤íŠ¸ íŠ¹ê°• í›„ê¸°
description: í•´ë‹¹ ê¸€ì—ì„œëŠ” AI ê°œë°œì ì·¨ì—…ì„ ìœ„í•œ ì½”ë”©í…ŒìŠ¤íŠ¸ íŠ¹ê°• í›„ê¸°ì— ëŒ€í•´ ì†Œê°œí•©ë‹ˆë‹¤.
date: 2024-05-21 19:50:43 +0900
last_modified_at: 2024-05-21 19:50:43 +0900
categories: [ ì¸ê³µì§€ëŠ¥, ë¶€íŠ¸ìº í”„ ]
tags: [ íŒ¨ìŠ¤íŠ¸ìº í¼ìŠ¤, íŒ¨ìŠ¤íŠ¸ìº í¼ìŠ¤AIë¶€íŠ¸ìº í”„, ì—…ìŠ¤í…Œì´ì§€íŒ¨ìŠ¤íŠ¸ìº í¼ìŠ¤, UpstageAILab#êµ­ë¹„ì§€ì›, íŒ¨ìŠ¤íŠ¸ìº í¼ìŠ¤ì—…ìŠ¤í…Œì´ì§€ì—ì´ì•„ì´ë©, íŒ¨ìŠ¤íŠ¸ìº í¼ìŠ¤ì—…ìŠ¤í…Œì´ì§€ë¶€íŠ¸ìº í”„ ]
pin: false
math: false
mermaid: false
image:
  path: assets/img/upstageai_background3.png
  alt: AI ê°œë°œì ì·¨ì—…ì„ ìœ„í•œ ì½”ë”©í…ŒìŠ¤íŠ¸ íŠ¹ê°• í›„ê¸°
---

# AI ê°œë°œì ì·¨ì—…ì„ ìœ„í•œ ì½”ë”©í…ŒìŠ¤íŠ¸ íŠ¹ê°• í›„ê¸°
## ğŸ—“ï¸ 2024.05.16 ~ 2024.05.20
3ì¼ê°„ ë…¸ì •í˜¸ ê°•ì‚¬ë‹˜ì˜ ì½”ë”©í…ŒìŠ¤íŠ¸ íŠ¹ê°•ì„ ë“¤ì—ˆë‹¤. ì½”ë”©í…ŒìŠ¤íŠ¸ëŠ” ì·¨ì—…ì„ ìœ„í•´ ê±°ì˜ ë°˜ í•„ìˆ˜ì ì¸ ìš”ì†Œì´ê¸° ë•Œë¬¸ì— ì´ë²ˆ ê¸°íšŒì— ì—´ì‹¬íˆ ë“¤ì–´ë³´ê¸°ë¡œ í–ˆë‹¤. íŠ¹íˆ, AI ê°œë°œìë¡œ ì·¨ì—…ì„ ëª©í‘œë¡œ í•˜ê³  ìˆëŠ” ë‚˜ì—ê²ŒëŠ” ë”ìš± ì¤‘ìš”í•œ ìš”ì†Œì´ê¸° ë•Œë¬¸ì´ë‹¤. 3ì¼ë™ì•ˆ DFS, DFS, HeapQ, Dijkstra, ì™„ì „íƒìƒ‰, Graphì— ëŒ€í•´ ë‹¤ë£¨ì—ˆë‹¤. ìˆ˜ì—…ë°©ì‹ì€ ê°•ì‚¬ë‹˜ê»˜ì„œ ê°„ë‹¨íˆ ì´ë¡ ì„¤ëª…ì„ í•´ì£¼ì…¨ê³  ê´€ë ¨ëœ ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œë¥¼ LeetCode í˜¹ì€ í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ì—ì„œ í’€ì–´ë³´ëŠ” ë°©ì‹ì´ì—ˆë‹¤. ì‚¬ì‹¤ 3ì¼ë§Œì— ë‹¤ì–‘í•œ ìë£Œêµ¬ì¡°ì™€ ì•Œê³ ë¦¬ì¦˜ì„ ì „ë¶€ í¡ìˆ˜í•˜ê¸°ì—ëŠ” ì–´ë ¤ì› ì§€ë§Œ, ê°•ì‚¬ë‹˜ê»˜ì„œ ì•Œê³ ë¦¬ì¦˜ì„ í’€ ë•Œ ì–´ë–¤ì‹ìœ¼ë¡œ ì ‘ê·¼í•´ì•¼ í•˜ëŠ”ì§€ì— ëŒ€í•œ ë°©í–¥ì„±ì„ ì œì‹œí•´ì£¼ì…”ì„œ ë§ì€ ë„ì›€ì´ ë˜ì—ˆë‹¤. ë˜í•œ, ì•Œê³ ë¦¬ì¦˜ì„ í’€ ë•Œ ì–´ë–¤ì‹ìœ¼ë¡œ ì½”ë“œë¥¼ ì‘ì„±í•´ì•¼ í•˜ëŠ”ì§€ì— ëŒ€í•œ ë°©ë²•ë¡ ì„ ë°°ì› ë‹¤.

## 1. [twosum](https://leetcode.com/problems/two-sum/) ë¬¸ì œ
[twosum](https://leetcode.com/problems/two-sum/) ì½”ë“œ êµ¬í˜„(ë°˜ë³µë¬¸)
```python
class Solution:
    def twoSum(self, nums, target):
        n = len(nums)
        for i in range(n):
            for j in range(i+1, n):
                if nums[i]+nums[j] == target:
                    return [i, j]
```

[twosum](https://leetcode.com/problems/two-sum/) ì½”ë“œ êµ¬í˜„(ì¬ê·€)
```python
class Solution:
    def twoSum(self, nums, target):
        n = len(nums)
        def find(start, value):
            for i in range(start+1, n):
                if nums[i] == value:
                    return i
            return -1
        for i in range(n):
            idx = find(i, target-nums[i])
            if idx != -1:
                return [i, idx]
```

## 2. [combination](https://leetcode.com/problems/combinations/) ì¡°í•©(ì¬ê·€)
```python
def solution(n, k):
    ans = []
    def recur(start, comb):
        if len(comb) == 2:
            ans.append(comb[:])
            return
        
        for i in range(start, n+1):
            comb.append(i)
            recur(i+1, comb)
            comb.pop()
    recur(1, [])

    return ans
```

## 3. [ì˜¬ë°”ë¥¸ ê´„í˜¸](https://leetcode.com/problems/valid-parentheses/)
```python
def solution(s):
    stack = []
    for p in s:
        if p == '(':
            stack.append(p)
        else:
            if not stack:
                return False
            stack.pop()
    return not stack
```

## 4. [keys and rooms](https://leetcode.com/problems/keys-and-rooms/)
```python
from collections import deque

class Solution:
    def canVisitAllRooms(self, rooms):
        n = len(rooms)
        visited = [False] * n
        def bfs(graph, start_v):
            # BFSì½”ë“œ ì‘ì„±í•˜ê¸°
            
            # visited[cur_v] = True
        bfs(rooms, start_v=0)

        return all(visited)
```
```python
class Solution:
    def canVisitAllRooms(self, rooms):
        n = len(rooms)
        visited = [False] * n
        
        def dfs(cur_v):
            visited[cur_v] = True
            for next_v in rooms[cur_v]:
                if not visited[next_v]:
                    dfs(next_v)

        dfs(cur_v=0)
        print(visited)
        return all(visited)

s = Solution()
s.canVisitAllRooms(rooms= [[1,3], [2,4], [0], [4], [ ], [3,4] ])    
```

## 5. ì•”ì‹œì  ê·¸ë˜í”„ DFS
```python
def dfs(r, c):
    visited[r][c] = True
    print((r,c), end=' ')
    for i in range(4):
        next_r = r + dr[i]
        next_c = c + dc[i]
        if 0 <= next_r < row_len and 0 <= next_c < col_len:
            if grid[next_r][next_c] == 1:
                if not visited[next_r][next_c]:
                    dfs(next_r, next_c)

grid = [
   [1, 1, 1, 1],
   [0, 1, 0, 1],
   [0, 1, 0, 1],
   [1, 0, 1, 1],
]
row_len, col_len = len(grid), len(grid[0])
visited = [[False] * col_len for _ in range(row_len)]
dr = [0, 1, 0, -1]
dc = [1, 0, -1, 0]
dfs(0, 0)
```

## 6. ì•”ì‹œì  ê·¸ë˜í”„ BFS
```python
from collections import deque
def bfs(r, c):
    q = deque()
    q.append((r,c))
    visited[r][c] = True

    while q:
        cur_r, cur_c = q.popleft()
        print((cur_r, cur_c), end ='->')
        for i in range(8):
            next_r = cur_r + dr[i]
            next_c = cur_c + dc[i]
            if 0 <= next_r < row_len and 0 <= next_c < col_len:
                if grid[next_r][next_c] == 1:
                    if not visited[next_r][next_c]:
                        q.append((next_r, next_c))
                        visited[next_r][next_c] = True

grid = [
   [1, 1, 1, 1],
   [0, 1, 0, 1],
   [0, 1, 0, 1],
   [1, 0, 1, 1],
]
row_len, col_len = len(grid), len(grid[0])
visited = [[False] * col_len for _ in range(row_len)]
dr = [0, 1, 0, -1, 1, 1, -1, -1]
dc = [1, 0, -1, 0, 1, -1, 1, -1]
bfs(0, 0)
```

## 7. [number of islands](https://leetcode.com/problems/number-of-islands/)
### BFS
```python
from collections import deque
class Solution:
    def numIslands(self, grid):
        row_len, col_len = len(grid), len(grid[0])
        visited = [[False] * col_len for _ in range(row_len)]
        cnt = 0
        dr = [0, 1, 0, -1]
        dc = [1, 0, -1, 0]
        def bfs(r, c):
            q = deque()
            q.append((r,c))
            visited[r][c] = True

            while q:
                cur_r, cur_c = q.popleft()
                for i in range(4):
                    next_r = cur_r + dr[i]
                    next_c = cur_c + dc[i]
                    if 0 <= next_r < row_len and 0 <= next_c < col_len:
                        if grid[next_r][next_c] == '1':
                            if not visited[next_r][next_c]:
                                q.append((next_r,next_c))
                                visited[next_r][next_c] = True

        for i in range(row_len):
            for j in range(col_len):
                if grid[i][j] == "1" and not visited[i][j]:
                    bfs(i,j)
                    cnt += 1
        return cnt

grid = [
    ["1", "1", "0", "0", "0"],
    ["1", "1", "0", "0", "0"],
    ["0", "0", "1", "1", "0"],
    ["0", "0", "0", "1", "1"],
]
s=Solution()
print(s.numIslands(grid))
```

### DFS
```python
from collections import deque
class Solution:
    def numIslands(self, grid):
        row_len, col_len = len(grid), len(grid[0])
        visited = [[False] * col_len for _ in range(row_len)]
        cnt = 0
        dr = [0, 1, 0, -1]
        dc = [1, 0, -1, 0]

        def dfs(cur_r,cur_c):
            visited[cur_r][cur_c] = True
            for i in range(4):
                next_r = cur_r + dr[i]
                next_c = cur_c + dc[i]
                if 0 <= next_r < row_len and 0 <= next_c < col_len:
                    if grid[next_r][next_c] == '1':
                        if not visited[next_r][next_c]:
                            dfs(next_r, next_c)

        for i in range(row_len):
            for j in range(col_len):
                if grid[i][j] == "1" and not visited[i][j]:
                    dfs(i,j)
                    cnt += 1
        return cnt

grid = [
    ["1", "1", "0", "0", "0"],
    ["1", "1", "0", "0", "0"],
    ["0", "0", "1", "1", "0"],
    ["0", "0", "0", "1", "1"],
]
s=Solution()
print(s.numIslands(grid))
```

## 8. [shortest path in binary matrix](https://leetcode.com/problems/shortest-path-in-binary-matrix/)
```python
from collections import deque
class Solution:
    def shortestPathBinaryMatrix(self, grid):
        if grid[0][0]==1:
            return -1
        # BFS ì´ˆê¸°ì„¸íŒ…
        q = deque()
        # q.append(start_r, start_c, start_distance)
        q.append((0, 0, 1))
        # vististed = ì´ˆê¸°í™”
        row_len, col_len = len(grid), len(grid[0])
        visited = [[False] * col_len for _ in range(row_len)]
        visited[0][0] = True
        dr = [1,1,1,0,0,-1,-1,-1]
        dc = [0,-1,1,1,-1,1,-1,0]
        while q:
            cur_r, cur_c, cur_d = q.popleft()
            if cur_r == row_len -1 and cur_c == col_len-1:
                return cur_d
            for i in range(8):
                next_r,next_c = cur_r+ dr[i],cur_c + dc[i]
                if 0 <=next_r <row_len and 0 <= next_c < col_len:
                    if grid[next_r][next_c] == 0 and not visited[next_r][next_c]:
                        q.append([next_r,next_c,cur_d+1])
                        visited[next_r][next_c] = True

            # í˜„ì¬ ë…¸ë“œ ë°©ë¬¸
            
            # ë‹¤ìŒ ë…¸ë“œ ì˜ˆì•½
            # q.append((next_r, next_c, cur_d+1))
        return -1 
````

***
    ğŸŒœ ê°œì¸ ê³µë¶€ ê¸°ë¡ìš© ë¸”ë¡œê·¸ì…ë‹ˆë‹¤. ì˜¤ë¥˜ë‚˜ í‹€ë¦° ë¶€ë¶„ì´ ìˆì„ ê²½ìš° 
    ì–¸ì œë“ ì§€ ëŒ“ê¸€ í˜¹ì€ ë©”ì¼ë¡œ ì§€ì í•´ì£¼ì‹œë©´ ê°ì‚¬í•˜ê² ìŠµë‹ˆë‹¤! ğŸ˜„


<a href="#" style="display: inline-block; padding: 5px 10px; color: #007bff; text-decoration: none; border: 0.5px solid #007bff; border-radius: 5px; float: right;">ë§¨ ìœ„ë¡œ ì´ë™í•˜ê¸°</a>